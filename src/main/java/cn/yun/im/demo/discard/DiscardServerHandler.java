package cn.yun.im.demo.discard;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.ReferenceCountUtil;

/**
 * Discard-Server indicates that it discards any received data
 * without any response.
 * Let us get straight from the handler implementation,
 * which handle I/O event generated by netty.
 * {@link ChannelInboundHandlerAdapter}
 * override channelRead() and exceptionCaught()
 *
 * handle server-end channel.
 *
 * @author: Liu Jinyun
 * @date: 2020/5/10/18:35
 */
public class DiscardServerHandler extends ChannelInboundHandlerAdapter {
    /**
     * channelRead event handler:
     * This method is called with received data,
     * whenever a new data is received from a client.
     *
     * @param ctx
     * @param msg the type of received message is ByteBuf.
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        // discard any data. The handler has to ignore the received message.
        // Keep in mind that ByteBuf is a reference-counted object, which has to be released explicit by release().
        // ((ByteBuf) msg).release();

        try {
        // usually you can do as follows.

            // to do sth with msg.
            // print received message :
//            ByteBuf byteBuf = (ByteBuf) msg;
//            while (byteBuf.isReadable()) {
//                System.out.print((char)byteBuf.readByte());
//                System.out.flush();
//            }

            // return a response:
            // ctx.write(msg) does not make message written to the wire, it's buffered internally
            // and then flushed into the wire by ctx.flush();
            // Alternatively, you can use ctx.writeAndFlush(msg) for brevity.
            ctx.write(msg);
            ctx.flush();
        } finally {
            // alternatively, release
            // Note that Netty releases it for you, when message is written to the wire.
            //ReferenceCountUtil.release(msg);
        }
    }


    /**
     * exceptionCaught event handler:
     * I/O error or handler exception occurred.
     *
     * @param ctx
     * @param cause
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        ctx.close();
    }


}
